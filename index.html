<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Marketing Facility Map</title>
    
    <!-- Load Tailwind CSS for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Set the map container to fill the entire viewport */
        #map {
            padding: 0;
            margin: 0;
            height: 100vh;
            width: 100vw;
            z-index: 0; /* Keep map layer below UI elements */
        }

        /* Ensure the body and html take up full height */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; 
            font-family: 'Inter', sans-serif;
        }

        /* Positioning for the Filter Control (mimicking Leaflet's top-left controls) */
        .top-left-control {
            position: absolute;
            top: 75px; /* Positioned below the default Leaflet zoom control */
            left: 10px;
            z-index: 10;
            width: 75px; /* Width for the button group */
            display: flex; /* Enable flex for buttons */
            flex-direction: column; /* Stack buttons vertically */
            margin-top: 5px;
        }

        .filter-panel {
            /* Positioned relative to its parent container (.top-left-control) */
            position: absolute;
            /* Adjust top to clear both filter and export buttons */
            top: 100%; 
            left: 0;
            width: 250px; /* Allow panel to be wider than the button group */
            max-height: 70vh;
            overflow-y: auto;
            margin-top: 0.75rem; /* Increased spacing below the buttons */
        }

        /* Positioning for the Map Legend Control (Bottom Right) */
        .bottom-right-control {
            position: absolute;
            bottom: 20px; 
            right: 10px;
            z-index: 10;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
    <!-- Define the "Inter" font for Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    
    <!-- Load Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body>

    <!-- Map Filter Control (Top Left) -->
    <div id="filter-control-container" class="top-left-control">
        <button id="filter-button" 
                class="px-2 py-1 bg-white text-gray-700 font-semibold rounded-md shadow-md border border-gray-300 hover:bg-gray-100 transition duration-150 w-full text-sm">
            Filter
        </button>
        
        <button id="export-csv-button" 
                class="px-2 py-1 bg-white text-gray-700 font-semibold rounded-md shadow-md hover:bg-gray-100 transition duration-150 w-full text-sm">
            Export
        </button>
        
        <!-- Filter Dropdown Panel (Initially Hidden) -->
        <div id="filter-panel" class="filter-panel hidden p-3 bg-white rounded-md shadow-xl text-left border border-gray-200">
            <div class="flex items-center mb-3 border-b pb-2 space-x-2">
                <button id="clear-all-button" class="text-xs px-2 py-1 bg-red-100 text-red-700 rounded hover:bg-red-200 transition duration-150 font-medium shadow-sm">Clear All</button>
                <button id="select-all-button" class="text-xs px-2 py-1 bg-green-100 text-green-700 rounded hover:bg-green-200 transition duration-150 font-medium shadow-sm">Select All</button>
                <button id="done-button" class="px-3 py-1 bg-blue-300 text-white text-xs rounded hover:bg-blue-600 transition duration-150 shadow-md">Done</button>

            </div>
            <h3 class="font-semibold text-gray-700 mb-2 border-b pb-1">Filter by Type:</h3>
            <div id="filter-checkboxes" class="space-y-1 text-sm">
                <!-- Dynamic Content -->
            </div>
        </div>
    </div>

    <!-- Map Legend Control (Bottom Right) -->
    <div id="legend-control-container" class="bottom-right-control p-3 bg-white rounded-md shadow-xl text-left border border-gray-200">
        <h3 class="font-bold text-gray-700 mb-2 border-b pb-1">Facility Type Legend:</h3>
        <div id="map-legend" class="space-y-1 text-sm">
            <!-- Dynamic Legend Content -->
        </div>
    </div>

    <!-- Map Container -->
    <div id="map">
        <!-- The map will be rendered here -->
    </div>

    
    <script>
        // Global state variables
        let allData = [];
        let markerGroup = null;
        let currentFilteredData = [];
        let typeColors = {}; // Stores the mapping of event type to color

        // variable configuration
        const csvUrl = "https://raw.githubusercontent.com/wicket85/marketing_viewer/refs/heads/main/ky_list_final.csv";
        const LATITUDE_FIELD = 'lat';
        const LONGITUDE_FIELD = 'long';
        const FILTER_FIELD = 'FACILITY_TYPE'

        // A distinct, accessible color palette for visualization
        const COLOR_PALETTE = [
            '#E53E3E', // Red
            '#38A169', // Green
            '#3182CE', // Blue
            '#D69E2E', // Yellow/Brown
            '#805AD5', // Purple
            '#DD6B20', // Orange
            '#00A3C4', // Cyan
            '#9F7AEA', // Violet
            '#ED64A6', // Pink
            '#718096', // Gray (use as fallback if more than 10 types)
            '#4A5568', // Dark Gray
        ];

        // Set up the map
        const map = L.map('map', {
            center: [38.26438, -85.74330],
            zoom: 12
        });

        // Add a tile layer (OpenStreetMap is the default for Leaflet)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            maxZoom: 19,
        }).addTo(map);

        /**
         * Generates a custom Leaflet DivIcon (a colored circle) for the marker.
         * @param {string} color The hex color code for the marker.
         * @returns {L.DivIcon} A custom Leaflet icon object.
         */
        function getColoredIcon(color) {
            return L.divIcon({
                className: 'custom-marker',
                // HTML for a small, colored circle
                html: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 2px #000;"></div>`,
                iconSize: [12, 12],
                iconAnchor: [6, 6] // Center the icon over the coordinates
            });
        }
        
        /**
         * Assigns a unique color from the palette to each event type.
         * @param {Array<string>} uniqueTypes Sorted array of unique event types.
         */
        function generateTypeColors(uniqueTypes) {
            typeColors = {};
            uniqueTypes.forEach((type, index) => {
                // Cycle through the COLOR_PALETTE
                typeColors[type] = COLOR_PALETTE[index % COLOR_PALETTE.length];
            });
        }
        
        /**
         * Renders the map legend in the bottom-right control panel.
         */
        function renderLegend() {
            const legendContainer = document.getElementById('map-legend');
            legendContainer.innerHTML = '';
            
            // Get sorted types from the keys of the color map
            const sortedTypes = Object.keys(typeColors).sort();

            sortedTypes.forEach(type => {
                const color = typeColors[type];
                const legendItem = document.createElement('div');
                legendItem.className = 'flex items-center space-x-2';
                
                // Color swatch element
                const swatch = document.createElement('span');
                swatch.className = 'w-3 h-3 rounded-full shadow-sm flex-shrink-0';
                swatch.style.backgroundColor = color;
                
                // Label text
                const label = document.createElement('span');
                label.textContent = type;

                legendItem.appendChild(swatch);
                legendItem.appendChild(label);
                legendContainer.appendChild(legendItem);
            });
        }

        // Simple function to parse the CSV string into an array of objects
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            // Assuming the first line is the header
            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length === headers.length) {
                    const row = {};
                    headers.forEach((header, j) => {
                        row[header] = values[j].trim();
                    });
                    data.push(row);
                }
            }
            return data;
        }

        function createPopupContent(item) {
            let popupContent = `<div class="font-bold text-lg mb-1">${item.NAME}</div>`;
            const combinedAddress = `${item.ADDRESS}<br>${item.CITY}, ${item.ST} ${item.ZIP}`;

            popupContent += `<p class="text-sm mb-2"><strong>Facility Type: </strong>${item.FACILITY_TYPE}</p>`;            
            popupContent += `<p class="text-sm mb-2"><strong>Phone: </strong>${item.PHONE}</p>`;
            popupContent += `<p class="text-sm mb-2"><strong>Address: </strong>${combinedAddress}</p>`;
            popupContent += `<p class="text-sm mb-2"><strong>Administrator: </strong>${item.ADMINISTRATOR}</p>`;
            popupContent += `<p class="text-sm mb-2"><strong>Bed Count: </strong>${item.BEDS}</p>`;

            return popupContent;
        }

        function plotMarkers(dataToPlot) {
            // 1. Clear existing markers
            if (markerGroup) {
                map.removeLayer(markerGroup);
            }
            
            const markers = [];

            // 2. Create new markers
            dataToPlot.forEach(item => {
                const lat = parseFloat(item[LATITUDE_FIELD]);
                const lon = parseFloat(item[LONGITUDE_FIELD]);

                // Skip if coordinates are invalid
                if (isNaN(lat) || isNaN(lon)) return; 

                const popupContent = createPopupContent(item);

                const marker = L.marker([lat, lon]).bindPopup(popupContent);
                markers.push(marker);
            });

            // 3. Add new markers to a FeatureGroup and add to map
            markerGroup = new L.FeatureGroup(markers);
            markerGroup.addTo(map);

            // 4. Zoom to the extent of the markers if there are any
            if (markers.length > 0) {
                map.fitBounds(markerGroup.getBounds(), { padding: [50, 50] });
            } else {
                // If no markers, zoom out to a general view
                map.setView([38.26438, -85.74330], 12);
            }
        }
        
        /**
         * Clears all existing markers and plots only the data matching the selected filters.
         * @param {Array<Object>} dataToPlot The array of data objects to display on the map.
         */
        function plotMarkers(dataToPlot) {
            // 1. Clear existing markers
            if (markerGroup) {
                map.removeLayer(markerGroup);
            }
            
            const markers = [];

            // 2. Create new markers
            dataToPlot.forEach(item => {
                const lat = parseFloat(item[LATITUDE_FIELD]);
                const lon = parseFloat(item[LONGITUDE_FIELD]);

                // Skip if coordinates are invalid
                if (isNaN(lat) || isNaN(lon)) return; 
                
                // Determine the marker color based on type
                const type = item[FILTER_FIELD];
                const color = typeColors[type] || '#000000'; 
                const icon = getColoredIcon(color);

                const popupContent = createPopupContent(item);

                // Apply the custom icon to the marker
                const marker = L.marker([lat, lon], { icon: icon }).bindPopup(popupContent);
                markers.push(marker);
            });

            // 3. Add new markers to a FeatureGroup and add to map
            markerGroup = new L.FeatureGroup(markers);
            markerGroup.addTo(map);

            // 4. Zoom to the extent of the markers if there are any
            if (markers.length > 0) {
                map.fitBounds(markerGroup.getBounds(), { padding: [50, 50] });
            } else {
                // If no markers, zoom out to a general view
                map.setView([30, -40], 2);
            }
        }
        
        /**
         * Gets the currently selected types from the checkboxes and calls plotMarkers.
         */
        function applyFilters() {
            const filterContainer = document.getElementById('filter-checkboxes');
            const checkboxes = filterContainer.querySelectorAll('input[type="checkbox"]:checked');
            
            // Get selected type values
            const selectedTypes = Array.from(checkboxes).map(cb => cb.value);

            // Filter the global data
            const filteredData = allData.filter(item => selectedTypes.includes(item[FILTER_FIELD]));
            
            plotMarkers(filteredData);
        }

        /**
         * Finds all unique values in the FILTER_FIELD column.
         * @param {Array<Object>} data The entire dataset.
         * @returns {Array<string>} Array of unique types.
         */
        function getUniqueTypes(data) {
            const types = new Set();
            data.forEach(item => {
                if (item[FILTER_FIELD] && item[FILTER_FIELD].trim() !== '') {
                    types.add(item[FILTER_FIELD].trim());
                }
            });
            return Array.from(types).sort();
        }

        /**
         * Converts the currently filtered data into a CSV string and triggers a download.
         */
        function exportFilteredData() {
            if (currentFilteredData.length === 0) {
                // In a production app, show a visual warning here instead of console.warn
                console.warn("No data to export.");
                return;
            }

            // 1. Get Headers (using keys from the first object, which assumes consistency)
            const headers = Object.keys(currentFilteredData[0]);
            
            // 2. Build the CSV rows
            const csvRows = [];
            // Add the header row
            csvRows.push(headers.join(','));

            // Add data rows
            for (const row of currentFilteredData) {
                const values = headers.map(header => {
                    // Escape double quotes and enclose in quotes
                    const value = row[header] !== undefined ? String(row[header]) : '';
                    // Basic CSV sanitization: replace quotes with double quotes and wrap in quotes
                    const escaped = value.replace(/"/g, '""'); 
                    return `"${escaped}"`;
                });
                csvRows.push(values.join(','));
            }

            // Combine all rows into a single string
            const csvString = csvRows.join('\n');

            // 3. Trigger download using a Blob and temporary link
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");

            if (link.download !== undefined) { 
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", "filtered_map_data.csv");
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url); // Clean up the URL object
            }
        }


        /**
         * Generates the filter UI with checkboxes for each unique type.
         * @param {Array<string>} uniqueTypes The array of unique types.
         */
        function renderFilterUI(uniqueTypes) {
            const container = document.getElementById('filter-checkboxes');
            container.innerHTML = ''; // Clear previous content

            uniqueTypes.forEach(type => {
                const id = `filter-${type.replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                const label = document.createElement('label');
                label.htmlFor = id;
                label.className = 'flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-1 rounded transition-colors';

                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = id;
                input.value = type;
                input.checked = true; // Select all by default
                input.className = 'rounded text-blue-500 focus:ring-blue-500';
                
                // Add the event listener to trigger filtering on change
                input.addEventListener('change', applyFilters);

                const span = document.createElement('span');
                span.textContent = type;

                label.appendChild(input);
                label.appendChild(span);
                container.appendChild(label);
            });
            
            // 2. Set up Select/Clear All button logic
            const selectAllButton = document.getElementById('select-all-button');
            const clearAllButton = document.getElementById('clear-all-button');
            
            const toggleAllCheckboxes = (checkedState) => {
                // Select all current checkboxes in the container
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = checkedState);
                applyFilters(); // Re-apply filters after state change
            };

            selectAllButton.addEventListener('click', (event) => {
                event.stopPropagation();
                toggleAllCheckboxes(true);
            });

            clearAllButton.addEventListener('click', (event) => {
                event.stopPropagation();
                toggleAllCheckboxes(false);
            });
            
            // 3. Set up Done button logic (New)
            const doneButton = document.getElementById('done-button');
            doneButton.addEventListener('click', (event) => {
                event.stopPropagation();
                filterPanel.classList.add('hidden'); // Close the panel
            });

            // 4. Set up Export button logic
            const exportButton = document.getElementById('export-csv-button');
            exportButton.addEventListener('click', (event) => {
                event.stopPropagation();
                exportFilteredData();
            });

            // 5. Set up Panel visibility toggle logic (Existing)
            const filterButton = document.getElementById('filter-button');
            const filterPanel = document.getElementById('filter-panel');
            
            filterButton.addEventListener('click', (event) => {
                event.stopPropagation(); 
                filterPanel.classList.toggle('hidden');
            });

            // Close filter panel if clicking outside the control container
            document.addEventListener('click', (event) => {
                const filterControlContainer = document.getElementById('filter-control-container');
                if (!filterControlContainer.contains(event.target)) {
                    filterPanel.classList.add('hidden');
                }
            });
            
             // Stop clicks inside the panel from closing it
            filterPanel.addEventListener('click', (event) => {
                event.stopPropagation();
            });
        }

        /**
         * Sets up the event listener for the export button, now that it's in the main UI.
         */
        function setupGlobalListeners() {
            const exportButton = document.getElementById('export-csv-button');
            exportButton.addEventListener('click', (event) => {
                event.stopPropagation();
                exportFilteredData();
            });
        }

        // Function to fetch and plot the data (Initial Load)
        async function loadDataAndPlot() {
            try {
                // 1. Fetch and Parse the data
                const response = await fetch(csvUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                
                // Store all data globally
                allData = parseCSV(csvText);
                
                // 2. Find unique types, generate colors, and render UI/Legend
                const uniqueTypes = getUniqueTypes(allData);
                generateTypeColors(uniqueTypes); // Generate the color mapping
                renderFilterUI(uniqueTypes);     // Render filters (now includes color swatches)
                renderLegend();                  // Render the map legend
                setupGlobalListeners();          // Setup new export button listener
                
                // 3. Initial Plot: show all data (since all checkboxes are checked by default)
                applyFilters(); 
                
            } catch (error) {
                console.error("Error loading or processing CSV data:", error);
                // Display error message on the map itself
                const errorElement = document.createElement("div");
                errorElement.className = "p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20 shadow-xl";
                errorElement.innerHTML = `<strong>Data Error:</strong> Could not load CSV. Check the console for details.`;
                document.getElementById("map").appendChild(errorElement);
            }
        }

        // Start the process
        loadDataAndPlot();

    </script>
</body>
</html>
